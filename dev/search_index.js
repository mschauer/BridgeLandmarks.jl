var documenterSearchIndex = {"docs":
[{"location":"#BridgeLandmarks.jl-1","page":"Home","title":"BridgeLandmarks.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [BridgeLandmarks]","category":"page"},{"location":"#BridgeLandmarks.construct_nfs-Tuple{Any,Any,Any}","page":"Home","title":"BridgeLandmarks.construct_nfs","text":"Construct sequence of Noisefields for AHS model\ndb: domainbound (sources are places on square grid specified by\n    (-db:2nfstd:db) x -db:2nfstd:db\nnfstd: standard deviation of noise fields (the smaller: the more noise fields we use)\nγ: if set to one, then the value of the  noise field on the positions is approximately 1 at all locations in the domain\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.landmarksforward-Union{Tuple{Pnt}, Tuple{Any,NState{Pnt,M} where M<:AbstractArray{Pnt,2},Any}} where Pnt","page":"Home","title":"BridgeLandmarks.landmarksforward","text":"Forward simulate landmarks process specified by P on grid t.\nReturns driving motion W and landmarks process X\nt: time grid\nx0: starting point\nP: landmarks specification\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.lm_mcmc-NTuple{15,Any}","page":"Home","title":"BridgeLandmarks.lm_mcmc","text":"Perform mcmc or sgd for landmarks model using the LM-parametrisation\ntt_:      time grid\n(xobs0,xobsT): observations at times 0 and T (at time T this is a vector)\nσobs: standard deviation of Gaussian noise assumed on xobs0 and xobsT\nmT: vector of momenta at time T used for constructing guiding term\nP: target process\n\nsampler: either sgd (stochastic gradient descent) or mcmc (Markov Chain Monte Carlo)\nobs_atzero: Boolean, if true there is an observation at time zero\nfixinitmomentato0: Boolean, if true we assume at time zero we observe zero momenta\nxinit: initial guess on starting state\n\nITER: number of iterations\nsubsamples: vector of indices of iterations that are to be saved\n\nρ: Crank-Nicolson parameter (ρ=0 is independence sampler)\nδ: step size for MALA updates on initial state (first component for positions, second component for momenta)\nprior_a: prior on parameter a\nprior_c: prior on parameter c\nprior_γ: prior on parameter γ\nσ_a: parameter determining update proposal for a [update a to aᵒ as aᵒ = a * exp(σ_a * rnorm())]\nσ_c: parameter determining update proposal for c [update c to cᵒ as cᵒ = c * exp(σ_c * rnorm())]\nσ_γ: parameter determining update proposal for γ [update γ to γᵒ as γᵒ = γ * exp(σ_γ * rnorm())]\n\noutdir: output directory for animation\npb:: Lmplotbounds (axis used for plotting landmarks evolution)\nupdatepars: logical flag for updating pars a, c, γ\nmakefig: logical flag for making figures\nshowmomenta: logical flag if momenta are also drawn in figures\n\nReturns:\nXsave: saved iterations of all states at all times in tt_\nparsave: saved iterations of all parameter updates ,\nobjvals: saved values of stochastic approximation to loglikelihood\nperc_acc: acceptance percentages (bridgepath - inital state)\n\n\nanim, Xsave, parsave, objvals, perc_acc = lm_mcmc_mv(tt_, (xobs0,xobsTvec), σobs, mT, P,\n         sampler, obs_atzero,\n         xinit, ITER, subsamples,\n        (δ, prior_a, prior_c, prior_γ, σ_a, σ_c, σ_γ),\n        outdir, pb; updatepars = true, makefig=true, showmomenta=false)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.GuidRecursions","page":"Home","title":"BridgeLandmarks.GuidRecursions","text":"GuidRecursions defines a struct that contains all info required for computing the guiding term and\nlikelihood (including ptilde term) for a single shape\n\n\n\n\n\n","category":"type"},{"location":"#BridgeLandmarks.GuidedProposal!","page":"Home","title":"BridgeLandmarks.GuidedProposal!","text":"struct that contains target, auxiliary process for each shape, time grid, observation at time 0, observations\n    at time T, number of shapes, and momenta in final state used for constructing the auxiliary processes\nguidrec is a vector of GuidRecursions, which contains the results from the backward recursions and gpupdate step at time zero\n\n\n\n\n\n","category":"type"},{"location":"#BridgeLandmarks.ObsInfo","page":"Home","title":"BridgeLandmarks.ObsInfo","text":"Observe V0 = L0 X0 + N(0,Σ0) and VT = LT X0 + N(0,ΣT)\nμT is just a vector of zeros (possibly remove later)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Tuple{BridgeLandmarks.InverseCholesky,Any}","page":"Home","title":"Base.:*","text":"Compute y = HX where Hinv = LL' (Cholesky decomposition\n\nInput are L and X, output is Y\n\ny=HX is equivalent to LL'y=X, which can be solved by first backsolving LZ=X for z and next backsolving L'Y=Z\n\nL is a lower triangular matrix with element of type UncMat X is a matrix with elements of type UncMat Returns a matrix with elements of type UncMat\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{BridgeLandmarks.InverseCholesky,BridgeLandmarks.NState}","page":"Home","title":"Base.:*","text":"Compute y = Hx where Hinv = LL' (Cholesky decomposition\n\nInput are L and x, output is y\n\ny=Hx is equivalent to LL'y=x, which can be solved by first backsolving Lz=x for z and next backsolving L'y=z\n\nL is a lower triangular matrix with element of type UncMat x is a State or vector of points Returns a State (Todo: split up again and return vector for vector input)\n\n\n\n\n\n","category":"method"},{"location":"#Base.conj!-Tuple{Array{#s24,2} where #s24<:(StaticArrays.SArray{Tuple{2,2},T,2,4} where T)}","page":"Home","title":"Base.conj!","text":"Compute transpose of square matrix of Unc matrices\n\nA = reshape([Unc(1:4), Unc(5:8), Unc(9:12), Unc(13:16)],2,2) B = copy(A) A conj!(B)\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO,BridgeLandmarks.NState}","page":"Home","title":"Base.show","text":"Good display of variable of type State\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.B!-Tuple{Any,Any,Any,LandmarksAux}","page":"Home","title":"Bridge.B!","text":"Compute B̃(t) * X (B̃ from auxiliary process) and write to out Both B̃(t) and X are of type UncMat\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.B!-Tuple{Any,Any,Any,MarslandShardlowAux}","page":"Home","title":"Bridge.B!","text":"Compute B̃(t) * X (B̃ from auxiliary process) and write to out Both B̃(t) and X are of type UncMat\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.B-Tuple{Any,LandmarksAux}","page":"Home","title":"Bridge.B","text":"Compute tildeB(t) for landmarks auxiliary process\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.B-Tuple{Any,MarslandShardlowAux}","page":"Home","title":"Bridge.B","text":"Compute tildeB(t) for landmarks auxiliary process\n\n\n\n\n\n","category":"method"},{"location":"#Bridge._b!-Tuple{Any,BridgeLandmarks.NState,BridgeLandmarks.NState,BridgeLandmarks.GuidedProposal!,Any}","page":"Home","title":"Bridge._b!","text":"Evaluate drift bᵒ of guided proposal at (t,x), write into out\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.a-Tuple{Any,Union{MarslandShardlow, MarslandShardlowAux}}","page":"Home","title":"Bridge.a","text":"Returns matrix a(t) for Marsland-Shardlow model\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.b!-Tuple{Any,Any,Any,LandmarksAux}","page":"Home","title":"Bridge.b!","text":"Evaluate drift of landmarks auxiliary process in (t,x) and save to out x is a state and out as well\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.b!-Tuple{Any,Any,Any,Landmarks}","page":"Home","title":"Bridge.b!","text":"Evaluate drift of landmarks in (t,x) and save to out x is a state and out as well\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.b!-Tuple{Any,Any,Any,MarslandShardlow}","page":"Home","title":"Bridge.b!","text":"Evaluate drift of landmarks in (t,x) and save to out x is a state and out as well\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.σ!-Tuple{Any,Any,Any,Any,BridgeLandmarks.GuidedProposal!}","page":"Home","title":"Bridge.σ!","text":"Evaluate σ(t,x) dW and write into out\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.σ!-Tuple{Any,Any,Any,Any,Union{Landmarks, LandmarksAux}}","page":"Home","title":"Bridge.σ!","text":"Compute sigma(t,x) * dm where dm is a vector and sigma is the diffusion coefficient of landmarks write to out which is of type State\n\n\n\n\n\n","category":"method"},{"location":"#Bridge.σ!-Tuple{Any,Any,Any,Any,Union{MarslandShardlow, MarslandShardlowAux}}","page":"Home","title":"Bridge.σ!","text":"compute σ(t,x) * dm and write to out\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.HMC-NTuple{5,Any}","page":"Home","title":"BridgeLandmarks.HMC","text":"Adapting Radford Neal's R implementation of Hamiltonian Monte Carlo with\nstepsize ϵ and L steps\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks._r!-Tuple{Any,BridgeLandmarks.NState,BridgeLandmarks.NState,BridgeLandmarks.GuidedProposal!,Any}","page":"Home","title":"BridgeLandmarks._r!","text":"Evaluate tilder (appearing in guiding term of guided proposal) at (t,x), write into out\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.amul-Tuple{Any,BridgeLandmarks.NState,Array{#s17,1} where #s17<:(StaticArrays.SArray{Tuple{2},T,1,2} where T),Union{Landmarks, LandmarksAux}}","page":"Home","title":"BridgeLandmarks.amul","text":"Multiply a(t,x) times a vector of points Returns a State (first multiply with sigma', via function σtmul, next left-multiply this vector with σ)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.amul-Tuple{Any,BridgeLandmarks.NState,BridgeLandmarks.NState,Union{Landmarks, LandmarksAux}}","page":"Home","title":"BridgeLandmarks.amul","text":"Multiply a(t,x) times a state Returns a state (first multiply with sigma', via function σtmul, next left-multiply this vector with σ)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.amul-Tuple{Any,BridgeLandmarks.NState,BridgeLandmarks.NState,Union{MarslandShardlow, MarslandShardlowAux}}","page":"Home","title":"BridgeLandmarks.amul","text":"Multiply a(t,x) times xin (which is of type state) Returns variable of type State\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.cholinverse!-Tuple{Any,Any}","page":"Home","title":"BridgeLandmarks.cholinverse!","text":"Solve L L'y =x using two backsolves, L should be lower triangular\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.convert_samplepath-Tuple{Any}","page":"Home","title":"BridgeLandmarks.convert_samplepath","text":"Useful for storage of a samplepath of states\nOrdering is as follows:\n1) time\n2) landmark nr\n3) for each landmark: q1, q2 p1, p2\n\nWith m time-steps, n landmarks, this entails a vector of length m * n * 2 * d\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.convert_samplepath-Tuple{Array{T,1} where T}","page":"Home","title":"BridgeLandmarks.convert_samplepath","text":"Useful for storage of a samplepath of states\nOrdering is as follows:\n0) shape\n1) time\n2) landmark nr\n3) for each landmark: q1, q2 p1, p2\n\nWith m time-steps, n landmarks, this entails a vector of length m * n * 2 * d\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.getpars-Tuple{BridgeLandmarks.GuidedProposal!}","page":"Home","title":"BridgeLandmarks.getpars","text":"Extract parameters from GuidedProposal! Q\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.guidingbackwards!-Tuple{BridgeLandmarks.Lm,Any,Any,Any,Any}","page":"Home","title":"BridgeLandmarks.guidingbackwards!","text":"Solve backwards recursions in L, M, μ parametrisation on grid t\nimplicit: if true, Euler backwards is used for solving ODE for Lt, else Euler forwards is used\n\nCase lowrank=true still gives an error: fixme!\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.hamiltonian-Tuple{Any,Any}","page":"Home","title":"BridgeLandmarks.hamiltonian","text":"Hamiltonian for deterministic part of landmarks model\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.init_guidrec-Tuple{Any,Any,Any}","page":"Home","title":"BridgeLandmarks.init_guidrec","text":"Initialise (allocate memory) a struct of type GuidRecursions for a single shape\nguidres = init_guidrec((t,obs_info,xobs0)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.kernel-Tuple{Any,Union{Landmarks, LandmarksAux, MarslandShardlow, MarslandShardlowAux}}","page":"Home","title":"BridgeLandmarks.kernel","text":"kernel in Hamiltonian\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.lm_gpupdate!-Union{Tuple{Pnt}, Tuple{Any,Array{Pnt,2},Any,Any,Any,Any,Any}} where Pnt","page":"Home","title":"BridgeLandmarks.lm_gpupdate!","text":"Guided proposal update for newly incoming observation at time zero.\nInformation on new observations at time zero is (L0, Σ0, xobs0)\nValues just after time zero, (Lt0₊, Mt⁺0₊, μt0₊) are updated to time zero, the result being\nwritten into (Lt0, Mt⁺0, μt0)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.lyapunovpsdbackward_step!-NTuple{7,Any}","page":"Home","title":"BridgeLandmarks.lyapunovpsdbackward_step!","text":"Version where B̃ and ã do not depend on try\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.lρtilde-Tuple{Any,Any,Any}","page":"Home","title":"BridgeLandmarks.lρtilde","text":"Compute log tildeρ(0,x_0) for the k-th shape\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.plotshapes-NTuple{4,Any}","page":"Home","title":"BridgeLandmarks.plotshapes","text":"plot initial and final shape, given by xobs0 and xobsT respectively\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.putpars!-Tuple{BridgeLandmarks.GuidedProposal!,Any}","page":"Home","title":"BridgeLandmarks.putpars!","text":"update parameter values in GuidedProposal! Q, i.e.\nnew values are written into Q.target and Q.aux is updated accordingly\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.set_obsinfo-Tuple{Any,Bool,Bool,Any,Any}","page":"Home","title":"BridgeLandmarks.set_obsinfo","text":"Make ObsInfo object\n\nThree cases:\n1) obs_atzero=true: this refers to the case of observing one landmark configuration at times 0 and T\n2) obs_atzero=false & fixinitmomentato0=false: case of observing multiple shapes at time T,\n    both positions and momenta at time zero assumed unknown\n3) obs_atzero=false & fixinitmomentato0=true: case of observing multiple shapes at time T,\n    positions at time zero assumed unknown, momenta at time 0 are fixed to zero\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.simguidedlm_llikelihood!-Tuple{Bridge.LeftRule,Any,Any,Any,BridgeLandmarks.GuidedProposal!,Any}","page":"Home","title":"BridgeLandmarks.simguidedlm_llikelihood!","text":"Simulate guided proposal and compute loglikelihood for one shape\nSolve sde inplace and return loglikelihood (thereby avoiding 'double' computations)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.simguidedlm_llikelihood!-Tuple{Bridge.LeftRule,Any,Any,Any,BridgeLandmarks.GuidedProposal!}","page":"Home","title":"BridgeLandmarks.simguidedlm_llikelihood!","text":"Simulate guided proposal and compute loglikelihood (vector version, multiple shapes)\n\nsolve sde inplace and return loglikelihood (thereby avoiding 'double' computations)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.slogρ!-NTuple{5,Any}","page":"Home","title":"BridgeLandmarks.slogρ!","text":"Stochastic approximation for loglikelihood.\n\nSimulate guided proposal and compute loglikelihood for starting point x0,\nguided proposals defined by Q and Wiener increments in W.\nGuided proposals are written into X.\nWrites vector of loglikelihoods into llout.\nReturns sum of loglikelihoods\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.update_guidrec!-Tuple{Any,Any}","page":"Home","title":"BridgeLandmarks.update_guidrec!","text":"Compute backward recursion for all shapes and write into field Q.guidrec\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.update_initialstate!-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,BridgeLandmarks.GuidedProposal!,Any,Any}","page":"Home","title":"BridgeLandmarks.update_initialstate!","text":"update initial state\nX:  current iterate of vector of sample paths\nXᵒ: vector of sample paths to write proposal into\nW:  current vector of Wiener increments\nll: current value of loglikelihood\nx, xᵒ, ∇x, ∇xᵒ: allocated vectors for initial state and its gradient\nsampler: either sgd (not checked yet) or mcmc\nQ::GuidedProposal!\nδ: vector with MALA stepsize for initial state positions (δ[1]) and initial state momenta (δ[2])\nupdatekernel:  can be :mala_pos, :mala_mom, :rmmala_pos\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.update_pars!-NTuple{10,Any}","page":"Home","title":"BridgeLandmarks.update_pars!","text":"For fixed Wiener increments and initial state, update parameters by random-walk-MH\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.update_path!-NTuple{10,Any}","page":"Home","title":"BridgeLandmarks.update_path!","text":"update bridges for all shapes using Crank-Nicholsen scheme with parameter ρ (only in case the method is mcmc)\nNewly accepted bridges are written into (X,W), loglikelihood on each segment is written into vector ll\n\nupdate_path!(X,Xᵒ,W,Wᵒ,Wnew,ll,x, Q, ρ, acc_pcn)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.z-NTuple{4,Any}","page":"Home","title":"BridgeLandmarks.z","text":"Define z(q) = < ∇K̄(q - δ,τ), λ >\nRequired for Stratonovich -> Ito correction in AHS-model\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.σp-Tuple{Any,Any,BridgeLandmarks.Noisefield}","page":"Home","title":"BridgeLandmarks.σp","text":"Suppose one noise field nf\nReturns diagonal matrix with noisefield for momentum at point location q (can be vector or Point)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.σq-Tuple{Any,Array{#s13,1} where #s13<:BridgeLandmarks.Noisefield}","page":"Home","title":"BridgeLandmarks.σq","text":"For AHS model compute total noise field on position experienced at a point x.\nUseful for plotting purposes.\n\nExample usage:\n    σq(Point(0.0, 0.0), nfs)\n    σq([0.0; 0.0], nfs)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.σq-Tuple{Any,BridgeLandmarks.Noisefield}","page":"Home","title":"BridgeLandmarks.σq","text":"Suppose one noise field nf\nReturns diagonal matrix with noisefield for position at point location q (can be vector or Point)\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.σt!-Union{Tuple{Pnt}, Tuple{Any,Any,NState{Pnt,M} where M<:AbstractArray{Pnt,2},Any,MarslandShardlow}} where Pnt","page":"Home","title":"BridgeLandmarks.σt!","text":"compute σ(t,x)' y, where y::State\nthe result is a vector of points that is written to out\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.σt!-Union{Tuple{Pnt}, Tuple{Any,Any,NState{Pnt,M} where M<:AbstractArray{Pnt,2},Any,Union{Landmarks, LandmarksAux}}} where Pnt","page":"Home","title":"BridgeLandmarks.σt!","text":"compute σ(t,x)' y, where y::State\nthe result is a vector of points that is written to out\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.σtmul-Union{Tuple{Pnt}, Tuple{Any,Any,NState{Pnt,M} where M<:AbstractArray{Pnt,2},Union{Landmarks, LandmarksAux}}} where Pnt","page":"Home","title":"BridgeLandmarks.σtmul","text":"Compute sigma(t,x)' * y where y is a state and sigma is the diffusion coefficient of landmarks returns a vector of points of length P.nfs\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.∇K̄-Tuple{Any,Any,Any}","page":"Home","title":"BridgeLandmarks.∇K̄","text":"Needed for b! in case P is auxiliary process\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.∇kernel-Tuple{Any,Any,Union{Landmarks, LandmarksAux, MarslandShardlow, MarslandShardlowAux}}","page":"Home","title":"BridgeLandmarks.∇kernel","text":"Needed for b! in case P is auxiliary process\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.∇kernel-Tuple{Any,Union{Landmarks, LandmarksAux, MarslandShardlow, MarslandShardlowAux}}","page":"Home","title":"BridgeLandmarks.∇kernel","text":"gradient of kernel in hamiltonian\n\n\n\n\n\n","category":"method"},{"location":"#BridgeLandmarks.∇z-NTuple{4,Any}","page":"Home","title":"BridgeLandmarks.∇z","text":"Define ∇z(q) = ∇ < ∇K̄(q - δ,τ), λ >\nRequired for Stratonovich -> Ito correction in AHS-model\n\n\n\n\n\n","category":"method"}]
}
